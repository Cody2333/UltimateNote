// std.cpp : Defines the entry point for the console application.
//

//ReadBitMap
//
#include <string>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <iostream>

#define WIDTHBYTES(bits) (((bits)+31)/32*4)
typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;
typedef long LONG;

//位图文件头信息结构定义
//其中不包含文件类型信息（由于结构体的内存结构决定，要是加了的话将不能正确读取文件信息）
typedef struct tagBITMAPFILEHEADER {
 WORD bfType;//固定为0x4d42
 DWORD bfSize; //文件大小
 WORD bfReserved1; //保留字，不考虑
 WORD bfReserved2; //保留字，同上
 DWORD bfOffBits; //实际位图数据的偏移字节数，即前三个部分长度之和
} BITMAPFILEHEADER;

//信息头BITMAPINFOHEADER，也是一个结构，其定义如下：
typedef struct tagBITMAPINFOHEADER{
 //public:
 DWORD biSize; //指定此结构体的长度，为40
 LONG biWidth; //位图宽
 LONG biHeight; //位图高
 WORD biPlanes; //平面数，为1
 WORD biBitCount; //采用颜色位数，可以是1，2，4，8，16，24，新的可以是32
 DWORD biCompression; //压缩方式，可以是0，1，2，其中0表示不压缩
 DWORD biSizeImage; //实际位图数据占用的字节数
 LONG biXPelsPerMeter; //X方向分辨率
 LONG biYPelsPerMeter; //Y方向分辨率
 DWORD biClrUsed; //使用的颜色数，如果为0，则表示默认值(2^颜色位数)
 DWORD biClrImportant; //重要颜色数，如果为0，则表示所有颜色都是重要的
} BITMAPINFOHEADER;

//调色板Palette，当然，这里是对那些需要调色板的位图文件而言的。24位和32位是不需要调色板的。
//（似乎是调色板结构体个数等于使用的颜色数。）
typedef struct tagRGBQUAD {
 //public:
 BYTE rgbBlue; //该颜色的蓝色分量
 BYTE rgbGreen; //该颜色的绿色分量
 BYTE rgbRed; //该颜色的红色分量
 BYTE rgbReserved; //保留值
} RGBQUAD;




void genWordData(tagRGBQUAD* pRGB, int height, int width);

std::string findWord(tagRGBQUAD* dataOfBmp);









void showBmpHead(BITMAPFILEHEADER* pBmpHead)
{
 printf("位图文件头:\n");
 printf("bmp格式标志bftype：0x%x\n",pBmpHead->bfType );
 printf("文件大小:%d\n",pBmpHead->bfSize);
 printf("保留字:%d\n",pBmpHead->bfReserved1);
 printf("保留字:%d\n",pBmpHead->bfReserved2);
 printf("实际位图数据的偏移字节数:%d\n",pBmpHead->bfOffBits);
}

void showBmpInforHead(tagBITMAPINFOHEADER* pBmpInforHead)
{
 printf("位图信息头:\n");
 printf("结构体的长度:%d\n",pBmpInforHead->biSize);
 printf("位图宽:%d\n",pBmpInforHead->biWidth);
 printf("位图高:%d\n",pBmpInforHead->biHeight);
 printf("biPlanes平面数:%d\n",pBmpInforHead->biPlanes);
 printf("biBitCount采用颜色位数:%d\n",pBmpInforHead->biBitCount);
 printf("压缩方式:%d\n",pBmpInforHead->biCompression);
 printf("biSizeImage实际位图数据占用的字节数:%d\n",pBmpInforHead->biSizeImage);
 printf("X方向分辨率:%d\n",pBmpInforHead->biXPelsPerMeter);
 printf("Y方向分辨率:%d\n",pBmpInforHead->biYPelsPerMeter);
 printf("使用的颜色数:%d\n",pBmpInforHead->biClrUsed);
 printf("重要颜色数:%d\n",pBmpInforHead->biClrImportant);
}
void showRgbQuan(tagRGBQUAD* pRGB)
{
 //printf("(%-3d,%-3d,%-3d) ",pRGB->rgbRed,pRGB->rgbGreen,pRGB->rgbBlue);
	if(pRGB->rgbRed < 50) //black
		printf("1 ");
	else //white
		printf("  ");
}
 
void main()
{
 BITMAPFILEHEADER bitHead;
 BITMAPINFOHEADER bitInfoHead;
 FILE* pfile;
 char strFile[50];
 char *BmpFileHeader;
 WORD *temp_WORD;
 DWORD *temp_DWORD;
 printf("please input the .bmp file name:\n");
 scanf("%s",strFile);
 
 pfile = fopen(strFile,"rb");//打开文件
    BmpFileHeader=(char *)calloc(14,sizeof(char));
 if(pfile!=NULL)
 {
  printf("file bkwood.bmp open success.\n");
  //读取位图文件头信息
  
  
  
  fread(BmpFileHeader,1,14,pfile);
  temp_WORD=(WORD* )(BmpFileHeader);
  bitHead.bfType=*temp_WORD;
  if(bitHead.bfType != 0x4d42)
  {
   printf("file is not .bmp file!");
   
   return;
  }
  temp_DWORD=(DWORD *)(BmpFileHeader+sizeof(bitHead.bfType));
  bitHead.bfSize=*temp_DWORD;
  temp_WORD=(WORD*)(BmpFileHeader+sizeof(bitHead.bfType)+sizeof(bitHead.bfSize));
  bitHead.bfReserved1=*temp_WORD;
  temp_WORD=(WORD*)(BmpFileHeader+sizeof(bitHead.bfType)+sizeof(bitHead.bfSize)+sizeof(bitHead.bfReserved1));
  bitHead.bfReserved2=*temp_WORD;
  temp_DWORD=(DWORD*)(BmpFileHeader+sizeof(bitHead.bfType)+sizeof(bitHead.bfSize)+sizeof(bitHead.bfReserved1)+sizeof(bitHead.bfReserved2));
  bitHead.bfOffBits=*temp_DWORD;
 
  
  
  showBmpHead(&bitHead);
  printf("\n\n");
 
  //读取位图信息头信息
  fread(&bitInfoHead,1,sizeof(BITMAPINFOHEADER),pfile);
  showBmpInforHead(&bitInfoHead);
  printf("\n");
  
 }
 else
 {
  printf("file open fail!\n");
  return;
 }
 
 tagRGBQUAD *pRgb ;
 if(bitInfoHead.biBitCount < 24)//有调色板
 {
  //读取调色盘结信息
  long nPlantNum = long(pow(2,double(bitInfoHead.biBitCount))); // Mix color Plant Number;
  pRgb=(tagRGBQUAD *)malloc(nPlantNum*sizeof(tagRGBQUAD));
  memset(pRgb,0,nPlantNum*sizeof(tagRGBQUAD));
  int num = fread(pRgb,4,nPlantNum,pfile);
  printf("Color Plate Number: %d\n",nPlantNum);
  printf("颜色板信息:\n");
  for (int i =0; i<nPlantNum;i++)
  {
   if (i%5==0)
   {
    printf("\n");
   }
   showRgbQuan(&pRgb[i]);
  }
  printf("\n");
 }

 int width = bitInfoHead.biWidth;
 int height = bitInfoHead.biHeight;
 //分配内存空间把源图存入内存
 int l_width = WIDTHBYTES(width* bitInfoHead.biBitCount);//计算位图的实际宽度并确保它为32的倍数
 BYTE *pColorData=(BYTE *)malloc(height*l_width);
 memset(pColorData,0,height*l_width);
 long nData = height*l_width;
 //把位图数据信息读到数组里
 fread(pColorData,1,nData,pfile);
 //将位图数据转化为RGB数据
 tagRGBQUAD* dataOfBmp;
 dataOfBmp = (tagRGBQUAD *)malloc(width*height*sizeof(tagRGBQUAD));//用于保存各像素对应的RGB数据
 memset(dataOfBmp,0,width*height*sizeof(tagRGBQUAD));
 if(bitInfoHead.biBitCount<24)//有调色板，即位图为非真彩色
 {
  int k;
  int index = 0;
  if (bitInfoHead.biBitCount == 1)
  {
   for(int i=0;i<height;i++)
    for(int j=0;j<width;j++)
    {
     BYTE mixIndex= 0;
     k = i*l_width + j/8;//k:取得该像素颜色数据在实际数据数组中的序号
     //j:提取当前像素的颜色的具体值
     mixIndex = pColorData[k];
     switch(j%8)
     {
     case 0:
      mixIndex = mixIndex<<7;
      mixIndex = mixIndex>>7;
      break;
     case 1:
      mixIndex = mixIndex<<6;
      mixIndex = mixIndex>>7;
      break;
     case 2:
      mixIndex = mixIndex<<5;
      mixIndex = mixIndex>>7;
      break;
     case 3:
      mixIndex = mixIndex<<4;
      mixIndex = mixIndex>>7;
      break;
     case 4:
      mixIndex = mixIndex<<3;
      mixIndex = mixIndex>>7;
      break;
     case 5:
      mixIndex = mixIndex<<2;
      mixIndex = mixIndex>>7;
      break;
     case 6:
      mixIndex = mixIndex<<1;
      mixIndex = mixIndex>>7;
      break;
     case 7:
      mixIndex = mixIndex>>7;
      break;
     }
     //将像素数据保存到数组中对应的位置
     dataOfBmp[index].rgbRed = pRgb[mixIndex].rgbRed;
     dataOfBmp[index].rgbGreen = pRgb[mixIndex].rgbGreen;
     dataOfBmp[index].rgbBlue = pRgb[mixIndex].rgbBlue;
     dataOfBmp[index].rgbReserved = pRgb[mixIndex].rgbReserved;
     index++;
    }
  }
  if(bitInfoHead.biBitCount==2)
  {
   for(int i=0;i<height;i++)
    for(int j=0;j<width;j++)
    {
     BYTE mixIndex= 0;
     k = i*l_width + j/4;//k:取得该像素颜色数据在实际数据数组中的序号
     //j:提取当前像素的颜色的具体值
     mixIndex = pColorData[k];
     switch(j%4)
     {
     case 0:
      mixIndex = mixIndex<<6;
      mixIndex = mixIndex>>6;
      break;
     case 1:
      mixIndex = mixIndex<<4;
      mixIndex = mixIndex>>6;
      break;
     case 2:
      mixIndex = mixIndex<<2;
      mixIndex = mixIndex>>6;
      break;
     case 3:
      mixIndex = mixIndex>>6;
      break;
     }
     //将像素数据保存到数组中对应的位置
     dataOfBmp[index].rgbRed = pRgb[mixIndex].rgbRed;
     dataOfBmp[index].rgbGreen = pRgb[mixIndex].rgbGreen;
     dataOfBmp[index].rgbBlue = pRgb[mixIndex].rgbBlue;
     dataOfBmp[index].rgbReserved = pRgb[mixIndex].rgbReserved;
     index++;

    }
  }
  if(bitInfoHead.biBitCount == 4)
  {
   for(int i=0;i<height;i++)
    for(int j=0;j<width;j++)
    {
     BYTE mixIndex= 0;
     k = i*l_width + j/2;
     mixIndex = pColorData[k];
     if(j%2==0)
     {//低
      mixIndex = mixIndex<<4;
      mixIndex = mixIndex>>4;
     }
     else
     {//高
      mixIndex = mixIndex>>4;
     }
     dataOfBmp[index].rgbRed = pRgb[mixIndex].rgbRed;
     dataOfBmp[index].rgbGreen = pRgb[mixIndex].rgbGreen;
     dataOfBmp[index].rgbBlue = pRgb[mixIndex].rgbBlue;
     dataOfBmp[index].rgbReserved = pRgb[mixIndex].rgbReserved;
     index++;
    }
  }
  if(bitInfoHead.biBitCount == 8)
  {
   for(int i=0;i<height;i++)
    for(int j=0;j<width;j++)
    {
     BYTE mixIndex= 0;
     k = i*l_width + j;
     mixIndex = pColorData[k];
     dataOfBmp[index].rgbRed = pRgb[mixIndex].rgbRed;
     dataOfBmp[index].rgbGreen = pRgb[mixIndex].rgbGreen;
     dataOfBmp[index].rgbBlue = pRgb[mixIndex].rgbBlue;
     dataOfBmp[index].rgbReserved = pRgb[mixIndex].rgbReserved;
     index++;
 
    }
  }
  if(bitInfoHead.biBitCount == 16)
  {
   for(int i=0;i<height;i++)
    for(int j=0;j<width;j++)
    {
     WORD mixIndex= 0;
     k = i*l_width + j*2;
     WORD shortTemp;
     shortTemp = pColorData[k+1];
     shortTemp = shortTemp<<8;
     mixIndex = pColorData[k] + shortTemp;
     dataOfBmp[index].rgbRed = pRgb[mixIndex].rgbRed;
     dataOfBmp[index].rgbGreen = pRgb[mixIndex].rgbGreen;
     dataOfBmp[index].rgbBlue = pRgb[mixIndex].rgbBlue;
     dataOfBmp[index].rgbReserved = pRgb[mixIndex].rgbReserved;
     index++;
    }
  }
 }
 else//位图为24位真彩色
 {
  int k;
  int index = 0;
  for(int i=0;i<height;i++)
   for(int j=0;j<width;j++)
   {
    k = i*l_width + j*3;
    dataOfBmp[index].rgbRed = pColorData[k+2];
    dataOfBmp[index].rgbGreen = pColorData[k+1];
    dataOfBmp[index].rgbBlue = pColorData[k];
    index++;
   }
 }

 printf("像素数据信息:\n");

 /*
 for (int i=height-1; i>=0; i--){
	for(int j= 0; j< width; ++j){
		showRgbQuan(&dataOfBmp[i*width+j]);
	}
	printf("\n");
 }
 */


//genWordData(dataOfBmp, height, width);	




 std::string word = findWord(dataOfBmp);
 std::cout<<word<<"\n";



 fclose(pfile);
 
 if (bitInfoHead.biBitCount<24)
 {
  free(pRgb);
 }
 free(dataOfBmp);
 free(pColorData);
   free(BmpFileHeader);
 printf("done\n");
 system("pause");
} 

void genWordData(tagRGBQUAD* dataOfBmp, int height, int width){
	//"犬是什"
	int tmp = 0;
	FILE* outfp = fopen("word.dat", "wb+");
	int tmpHeight = 0;
	char words[16][2];
	for(int i= 0; i< 16; i++){
		words[i][0] = 0;
		words[i][1] = 0;
	}
	for (int i=height-1; i>=0; i--){
		for(int j= 0; j< width; ++j){
			showRgbQuan(&dataOfBmp[i*width+j]);
			if(dataOfBmp[i*width+j].rgbRed < 50){ //black
				words[tmpHeight][j/8] = words[tmpHeight][j/8] | (1<<(7-(j%8)));
			}
		}
		printf("\n");
		tmpHeight++;
		if(tmpHeight == 16){
			tmpHeight = 0;
			
			//testing
			/*
			for(int i= 0; i< 16; i++){
				for(int j= 0; j< 16; j++){
					if(((words[i][j/8] >> (7-(j%8))) & 1) == 0){ //white
						printf("  ");
					}else{
						printf("1 ");
					}
				}
				printf("\n");
			}
			printf("\n");
			for(int i= 0; i< 16; i++){
				words[i][0] = 0;
				words[i][1] = 0;
			}
			*/


			//output to data
			/*
			if(tmp == 0)
				fprintf(outfp, "犬");
			else if(tmp == 1)
				fprintf(outfp, "是");
			else if(tmp == 2)
				fprintf(outfp, "什");
			tmp++;
			for(int i= 0; i< 16; i++){
				fprintf(outfp, "%c", words[i][0]);
				fprintf(outfp, "%c", words[i][1]);
			}
			*/
		}
	}
	fclose(outfp);
}


std::string findWord(tagRGBQUAD* dataOfBmp){
	std::string rslt;
	char tmp[4];
	char words[16][2];
	char input[16][2];

	//deal with input ... rgb to array

	for(int i= 0; i< 16; i++){
		input[i][0] = 0;
		input[i][1] = 0;
	}
	for (int i=0; i< 16; i++){
		for(int j= 0; j< 16; ++j){
			if(dataOfBmp[i*16+j].rgbRed < 50){ //black
				input[15-i][j/8] = input[15-i][j/8] | (1<<(7-(j%8)));
			}
		}
	}

	//testing
	/*for(int i= 0; i< 16; i++){
		for(int j= 0; j< 16; j++){
			if(((input[i][j/8] >> (7-(j%8))) & 1) == 0){ //white
				printf("  ");
			}else{
				printf("1 ");
			}
		}
		printf("\n");
	}
	*/
	

	//read data
	FILE* fp = fopen("word.dat", "rb");
	

	
	while(fread(tmp, 2, 1, fp)){
		tmp[2] = 0;
		rslt = std::string(tmp);
	

		for(int i= 0; i< 16; i++){
			fread(words[i], 1, 1, fp);
			fread(words[i]+1, 1, 1, fp);
		}
	
		char diff;
		int diffNum = 0;
		for(int i= 0; i< 16; i++){
			diff = words[i][0] ^ input[i][0];
			for(int i= 0; i< 8; i++){
				diffNum += (diff>>i)%2;
			}
		}
		std::cout<<rslt<<" "<<diffNum<<std::endl;

	}

	return rslt;
}